package Aufgaben;

import java.util.Vector;
import Aufgaben.Element;

/**
 * CommandList ist eine Klasse die die ganzen Methoden für eine doppelt
 * verkettete Liste beinhaltet.
 * 
 * @author Andreas Sautter u. Jan Engling
 * @version 1.0
 * @since JDK 1.8
 */
public class CommandList {
	private Element root = null;
	private CommandListModel clm = null;
	
	public CommandList(CommandListModel clm){
		this.clm = clm;
	}
	/**
	 * Mit der Methode add kann ein neues Listen Element hinzugefügt werden.
	 * 
	 * @param c Objekt von Typ Command
	 * @return True wenn das Element erfolgreich hinzugefügt wurde.
	 */
	public boolean add(Command c) {
		Element pos = new Element(c);

		if (root == null) {
			root = pos; 					// Wurzel auf erstes Element setzten
			clm.dataChanged();
			return true;
		} else {
			pos.setNext(root); 				// Aktuelle Wurzel dem neuen Element als Next zuweisen
			root.setPrev(pos); 				// Dem "alten ersten" Element das vorhergehende Element zuweisen
			root = pos; 					// neuer Listenanfang der Variable root zuweisen
			clm.dataChanged();
			return true;
		}
	}
	
	public void print(){
		Element aktPos = root;

		for (int i = groeße(root); i != 0; i--) {
			
			System.out.println(aktPos.getElement().toString());
			
			aktPos = aktPos.getNext();
		}
	}
	/**
	 * Mit der Methode groeße kann die Laenge der Liste bestimmt werden.
	 * 
	 * @param root Anfang der verketteten Liste
	 * @return Liefert die Laenge der Liste zurück.
	 */
	public int groeße() {
		int counter = 0;
		Element aktPos = root; 				// Hilfsvariable

		if (root == null) { 				// Wenn Liste leer
			return counter;
		} else {
			do { 							// Größe der Liste bestimmen
				counter++; 					// Zähler
				aktPos = aktPos.getNext(); 	// Liste durchitterieren
			} while (aktPos != null);
			return counter;
		}
	}

	/**
	 * Mit der Methode remove kann ein Element an einer bestimmten Position
	 * gelöscht werden.
	 * 
	 * @param pos Position der verketteten Liste
	 * 
	 * @return True, wenn das Element erfolgreich gelöscht wurde, false wenn
	 *         pos außerhalb Listengröße. 
	 */
	public boolean remove(int pos) {
		Element aktPos = root;

		for (int i = groeße(root); i != 0; i--) { 				// i wird auf Counter gesetzt und es wird runtergezählt(so arbeitet auch die Liste)
			if (i == pos + 1) {
				Element vorAktPos = aktPos.getPrev(); 			// Adresse vom vorherigen und folgenden Element zugreifen
				Element nachAktPos = aktPos.getNext();

				if (vorAktPos == null && nachAktPos != null) {  // Fallunterscheidung 1.Fall: Anfang; 2.Fall: Mitte 3.Fall: Ende;
					root = nachAktPos;
					root.setPrev(null);
					ControlModel.getInstance().getClm().dataChanged();
					return true;
				} else if (vorAktPos != null && nachAktPos != null) {
					vorAktPos.setNext(aktPos.getNext());
					nachAktPos.setPrev(aktPos.getPrev());
					ControlModel.getInstance().getClm().dataChanged();
					return true;
				} else if (vorAktPos != null && nachAktPos == null) {
					vorAktPos.setNext(null);
					ControlModel.getInstance().getClm().dataChanged();
					return true;
				}else if (vorAktPos == null && nachAktPos == null){
					root = null;
					return true;
				}
			}
			aktPos = aktPos.getNext();
		}
		return false;
	}

	/**
	 * Mit der Methode get kann auf ein bestimmtes Element in der Liste
	 * zugegriffen werden und liefert den Inhalt des Elements zurück.
	 * 
	 * @param pos Position des zu holenden Listenelements
	 * 
	 * @return Gibt Objektt von Typ Command zurück oder null wenn pos nicht
	 *         enthalten
	 */
	public Command get(int pos) {
		Element aktPos = root;

		for (int i = groeße(root); i != 0; i--) { 	// i wird auf Counter gesetzt und es wird runtergezählt(so arbeitet auch die Liste)
			if (i == pos + 1) {
				return aktPos.getElement();
			}
			aktPos = aktPos.getNext();
		}
		return null; 								// Wenn es die Postion nicht gibt wird null zurück gegeben
	}

	/**
	 * Mit der Methode moveUp kann ein bestimmtes Element in der Liste hoch
	 * geschoben werden.
	 * 
	 * @param pos Position des zu verschiebenden Listenelements
	 * @return Gibt true zurück wenn die Operation erfolgreich war, false wenn
	 *         erfolglos
	 */
	public boolean moveUp(int pos) {
		Element aktPos = root;

		for (int i = groeße(root); i != 0; i--) { 				// i wird auf Counter gesetzt und es wird runtergezählt(so arbeitet auch die Liste)
			if (i == pos + 1) {
				Element nachAktPos = aktPos.getNext(); 			// Adresse vom folgenden Element zugreifen

				if (aktPos.getNext() != null) {
					Command temp = nachAktPos.getElement(); 	// Elemente vertauschen
					nachAktPos.setElement(aktPos.getElement());
					aktPos.setElement(temp);
					return true;
				} else {
					return false;
				}
			}
			aktPos = aktPos.getNext();
		}
		//clm.dataChanged();
		return false;
	}

	/**
	 * Mit der Methode moveDown kann ein bestimmtes Element in der Liste runter
	 * geschoben werden.
	 * 
	 * @param pos Position des zu verschiebenden Listenelements
	 * 
	 * @return Gibt true zurück, wenn die Operation erfolgreich war, false wenn
	 *         erfolglos.
	 */
	public boolean moveDown(int pos) {
		Element aktPos = root;

		for (int i = groeße(root); i != 0; i--) {	 			// i wird auf Counter gesetzt und es wird runtergezählt(so arbeitet auch die Liste)
			if (i == pos + 1) {
				Element vorAktPos = aktPos.getPrev(); 			// Adresse vom folgenden Element zugreifen

				if (aktPos.getPrev() != null) {
					Command temp = vorAktPos.getElement(); 		// Elemente vertauschen
					vorAktPos.setElement(aktPos.getElement());
					aktPos.setElement(temp);
					return true;
				} else {
					return false;
				}
			}
			aktPos = aktPos.getNext();
		}
		//clm.dataChanged();
		return false;
	}
	
	
	//Clear list
	/**
	 * Methode um die verkette Liste in einen Vektor String zu wandeln.
	 * 
	 * @return Gibt Vektor mit Werten zurück.
	 */
	public Vector<String> readList (){
		Vector<String> s = new Vector<String>();
		Element aktPos = root;
		for (int i=0; aktPos.getNext()!=null; i++){
			aktPos = aktPos.getNext();
		}
		if(groeße(root)==0){										// 1.Fall: Liste leer 
			return null;
		}else if (groeße(root)==1){                                 // 2.Fall: Liste besitzt nur ein Element
			s.addElement(aktPos.getElement().toString());
			return s;
		}
		for (int j=0; aktPos.getPrev()!=null; j++){					// 3.Fall Liste besitzt mehr als 1 Element
			s.add(aktPos.getElement().toString());
			aktPos = aktPos.getPrev();
		}
		s.add(root.getElement().toString());						// root wird noch angehängt
		return s;
	}
}
